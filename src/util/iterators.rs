use std::collections::VecDeque;

/// å‡½æ•°å¼è¿­ä»£å™¨
/// * ğŸ¯æœ€åˆç”¨äºã€ŒåŸºäº**é—­åŒ…/å‡½æ•°æŒ‡é’ˆ**çµæ´»å®šä¹‰è¿­ä»£å™¨ã€
/// * ğŸš©ç›´æ¥å®šä¹‰ä¸€ä¸ª[`FnIterator::next`]ï¼Œå¹¶ç›´æ¥åœ¨[`Iterator::next`]ä¸­æ‰§è¡Œ
///   * ğŸ“Œè°ƒç”¨æ—¶çš„ã€Œå¯å˜å…ƒç´ ã€åŸºæœ¬ä¾èµ–é—­åŒ…æ•è·çš„å¤–éƒ¨å˜é‡
/// * âŒæ— æ³•ç”¨äºä»ã€Œç¼“å†²åŒºè¿­ä»£å™¨ã€ç”Ÿæˆã€Œå¤´è¿­ä»£å™¨ã€ï¼šæ— æ³•è¿”å›æŒ‡å‘å¯å˜é—­åŒ…[`FnMut`]çš„å†…éƒ¨å˜é‡çš„å¼•ç”¨
///   * ğŸ“Œå¼ƒç”¨åŸå› ï¼šé—­åŒ…çš„æ‰€æœ‰æƒé—®é¢˜
/// * â—æ ‡å‡†åº“ä¸­å·²ç»æœ‰é›†æˆäº†ï¼šå‚è§[`std::iter::from_fn`]
///   * ğŸ“ä¸€äº›ç»†èŠ‚å®ç°å·®å¼‚
///     * ğŸ“Œæ ‡å‡†åº“ç›´æ¥ä½¿ç”¨å•å…ƒç»„structï¼Œè€Œæœ¬structä½¿ç”¨æ™®é€šç»“æ„ä½“
///     * ğŸ“Œæ ‡å‡†åº“æŠŠã€Œå‡½æ•°ç±»å‹é™åˆ¶ã€ä»ã€Œå®šä¹‰æ—¶ã€ç•™åˆ°äº†ã€Œå®ç°æ—¶ã€
///   * ğŸš©ã€2024-03-10 11:15:11ã€‘ä»£ç è®¡åˆ’å°å­˜ï¼Œä»¥å’Œæ ‡å‡†åº“ä½œå¯¹æ¯”
pub struct FnIterator<F, T>
where
    F: FnMut() -> Option<T>,
{
    f: F,
}

impl<F, T> FnIterator<F, T>
where
    F: FnMut() -> Option<T>,
{
    /// æ„é€ å‡½æ•°ï¼šç›´æ¥åŸºäº å‡½æ•°æŒ‡é’ˆ/é—­åŒ… åˆ›å»ºè¿­ä»£å™¨
    pub fn new(f: F) -> Self {
        Self { f }
    }
}

/// å®ç°æ ‡å‡†è¿­ä»£å™¨æ¥å£
impl<F, T> Iterator for FnIterator<F, T>
where
    F: FnMut() -> Option<T>,
{
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        (self.f)()
    }
}

// ! âŒã€2024-03-04 20:58:35ã€‘å®è·µï¼šå› ä¸ºã€Œæ‰“åŒ…åéœ€è¦ä»ä¸­å€Ÿç”¨å€¼ã€çš„å€Ÿç”¨é—®é¢˜ï¼Œå†æ¬¡å¼ƒç”¨ã€Œç‹¬ç«‹ä½¿ç”¨ã€å¤´è¿­ä»£å™¨ã€ç®¡ç†è¿­ä»£è¿‡ç¨‹ã€çš„æƒ³æ³•
// /// ! âŒã€2024-03-04 20:28:24ã€‘æ— æ³•ç»ç”±ã€Œæ–°structä»£ç†ã€ä¸º[`BufferIterator`]ç”Ÿæˆã€Œå¤´è¿­ä»£å™¨ã€ï¼ˆåŒæ—¶ä¸è·å–æ‰€æœ‰æƒï¼‰
// /// ! ç¼–è¯‘é”™è¯¯ä¿¡æ¯å¦‚ä¸‹ï¼š
// /// ```plaintext
// /// error: lifetime may not live long enough
// ///   --> src\util\iterators.rs:51:21
// ///   |
// /// 42 | impl<'a, T, I> Iterator for HeadIter<'a, T, I>
// ///   |      -- lifetime `'a` defined here
// /// ...
// /// 48 |     fn next(&mut self) -> Option<Self::Item> {
// ///   |             - let's call the lifetime of this reference `'1`
// /// ...
// /// 51 |             true => Some(self.0.buffer.back().unwrap()),
// ///   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method was supposed to return data with lifetime `'a` but it is returning data with lifetime `'1`
// /// ```
// ///
// /// ! ğŸš©ã€2024-03-04 20:32:17ã€‘ä¸å†é‡‡ç”¨ã€ŒåŸè¿­ä»£å™¨çš„å¼•ç”¨ã€ï¼Œè½¬å‘ã€Œè·å–æ‰€æœ‰æƒï¼Œç„¶åunwrapè¿”å›ã€çš„æ–¹æ³•
// ///  * æ­¤å¤„å°†ï¼ˆçŸ­æš‚ï¼‰è·å–å…¶æ‰€æœ‰æƒï¼Œç„¶åå¯é€šè¿‡[`Self::unwrap`]æ–¹æ³•è§£åŒ…
// // pub struct HeadIter<'a, T, I>(&'a mut BufferIterator<T, I>) // ! ä¸å†ä½¿ç”¨å¼•ç”¨ï¼Œå› æ­¤ä¸å†éœ€è¦ç”Ÿå‘½å‘¨æœŸå‚æ•°
// pub struct HeadIter<T, I>(BufferIterator<T, I>)
// where
//     // T: 'a, // ! å¯¹ä¸‹æ–¹ã€Œç”Ÿå‘½å‘¨æœŸé—®é¢˜ã€æ— æµäºäº‹
//     I: Iterator<Item = T>;

// impl<T, I> HeadIter<T, I>
// where
//     // T: 'a, // ! å¯¹ä¸‹æ–¹ã€Œç”Ÿå‘½å‘¨æœŸé—®é¢˜ã€æ— æµäºäº‹
//     I: Iterator<Item = T>
// {
//     /// æ„é€ å‡½æ•°
//     pub fn new(iter: BufferIterator<T, I>) -> Self {
//         Self(iter)
//     }

//     /// è§£åŒ…
//     /// * âš ï¸æ¶ˆè€—è‡ªèº«æ‰€æœ‰æƒ
//     pub fn unwrap(self) -> BufferIterator<T, I>{
//         self.0
//     }
// }

// /// å®ç°æ ‡å‡†è¿­ä»£å™¨æ¥å£
// impl<T, I> Iterator for HeadIter<T, I>
// where
//     // T: 'a, // ! å¯¹ä¸‹æ–¹ã€Œç”Ÿå‘½å‘¨æœŸé—®é¢˜ã€æ— æµäºäº‹
//     I: Iterator<Item = T>,
// {
//     /// ! ğŸ’­æƒ³è¿”å›å¼•ç”¨ï¼Œä½†è¿™é‡Œ`Item`å®šä¹‰`&T`éœ€è¦é™„åŠ ç”Ÿå‘½å‘¨æœŸï¼›
//     /// * âŒæƒ³åœ¨ç»“æ„ä½“å®šä¹‰å¤„é™„åŠ ç”Ÿå‘½å‘¨æœŸæ ‡è¯†ï¼Œä½†å´æŠ¥é”™ã€Œæœªä½¿ç”¨çš„ç”Ÿå‘½å‘¨æœŸç±»å‹ã€
//     /// * ğŸš©ã€2024-03-04 20:43:41ã€‘ç»“è®ºï¼šå› ä¸ºç”Ÿå‘½å‘¨æœŸé—®é¢˜ï¼Œå¼ƒæ‰ã€Œè¿”å›ã€æ–°å¢çš„å…ƒç´ ã€çš„å¼•ç”¨ã€çš„è¿”å›ç±»å‹
//     type Item = ()/* &T */;
//     fn next(&mut self) -> Option<Self::Item> {
//         match self.0.head_next() {
//             // æœ‰ä»ã€Œå†…éƒ¨è¿­ä»£å™¨ã€ä¸­æ‹¿åˆ°å…ƒç´ â‡’è¿”å›è¿™ä¸ªå…ƒç´ çš„ä¸å¯å˜å¼•ç”¨
//             true => Some(()/* self.0.buffer.back().unwrap() */),
//             // æ²¡æœ‰ä»ã€Œå†…éƒ¨è¿­ä»£å™¨ã€ä¸­æ‹¿åˆ°å…ƒç´ â‡’è¿”å›None
//             false => None,
//         }
//     }
// }

/// ç¼“å†²è¿­ä»£å™¨
/// * ğŸ¯æœ€åˆç”¨äºã€Œåªä¼šä»å‰å¾€åè§£æå­—ç¬¦ä¸²ï¼Œé™¤äº†ã€ç¼“å†²åŒºã€ä¸ä¼šè¿›è¡Œå›æº¯ã€çš„å­—ç¬¦ä¸²è§£æå™¨
/// * ğŸš©ç”¨äº**å¸¦ç¼“å†²åœ°ä»æŸä¸ªè¿­ä»£å™¨é‡Œè¿­ä»£ä¸œè¥¿**
///
/// ! âš ï¸ã€2024-03-03 23:29:48ã€‘ç›®å‰å› ä¸ºã€Œéœ€è¦è¿­ä»£å‡ºå»ï¼ŒåŒæ—¶è¿˜è¦ç¼“å­˜ã€è¦æ±‚å…¶å†…å…ƒç´ å¯ä»¥è¢«å¤åˆ¶ï¼ˆå®ç°[`Clone`]ï¼Œå¦‚[`char`]ï¼‰
///   * å› æ­¤ï¼Œè¯¥è¿­ä»£å™¨ä¼š**è‡ªåŠ¨å¤åˆ¶**å…¶æ‰€å°è£…è¿­ä»£å™¨ä¸­çš„å…ƒç´ 
pub struct BufferIterator<T, I>
where
    I: Iterator<Item = T>,
{
    iterator: I,
    /// è®°å½•ã€Œå·²è¿­ä»£æœªæ¸…ç†ã€çš„å…ƒç´ 
    /// * ğŸš©ä½¿ç”¨**é˜Ÿåˆ—**ä»¥ä¾¿åœ¨ã€Œç¼“å†²åŒºé€’è¿›ã€æ—¶å¼¹å‡ºå…ƒç´ 
    buffer: VecDeque<T>,
    /// è®°å½•è¿­ä»£åˆ°çš„ã€Œå¤´ç´¢å¼•ã€ï¼ˆç¼“å†²åŒºæœ«å°¾ï¼‰
    /// * å¯èƒ½ä¸ºç©ºï¼šå°šæœªå¼€å§‹è¿­ä»£æ—¶ï¼ˆæœ€å¼€å§‹è¿­ä»£å°†è®¾ç½®åœ¨0ï¼‰
    ///
    /// ! âš ï¸ä¸åŒäºã€Œç¼“å†²åŒºå¼€å¤´ã€æ‰€è¿­ä»£åˆ°çš„ç´¢å¼•
    head: usize,
    /// æ˜¯å¦å¼€å§‹è¿­ä»£
    /// * ğŸ¯ä¸ºäº†åœ¨è·å–ã€Œå¤´ç´¢å¼•ã€æ—¶é¿å…ã€Œè·å–ç©ºè¿­ä»£å™¨çš„å¤´ç´¢å¼•ã€
    is_began: bool,
    /// æ˜¯å¦è¿­ä»£åˆ°äº†æœ«å°¾
    /// * ğŸ¯ä¸ºäº†åœ¨è·å–ã€Œæ˜¯å¦è¿­ä»£å®Œã€æ—¶ä¸ä¿®æ”¹è¿­ä»£å™¨
    is_ended: bool,
}

impl<T, I> BufferIterator<T, I>
where
    I: Iterator<Item = T>,
{
    /// æ„é€ å‡½æ•°
    /// * ğŸ“Œ`head`åˆå§‹ä¸º`0`ï¼Œ`is_began`åˆå§‹ä¸º`false`ï¼Œ`is_ended`åˆå§‹ä¸º`false`
    /// * ğŸ“Œ`buffer`åˆå§‹ä¸ºç©º
    pub fn new(iterator: I) -> Self {
        BufferIterator {
            // è½½å…¥è¿­ä»£å™¨
            iterator,
            buffer: VecDeque::new(),
            // å¤´ç´¢å¼•åˆå§‹åŒ–ä¸º0
            head: 0,
            // æœªå¼€å§‹è¿­ä»£ï¼Œæœªç»“æŸè¿­ä»£
            is_began: false,
            is_ended: false,
        }
    }

    /// è·å–ã€Œå¤´ç´¢å¼•ã€
    /// * ğŸ“Œå½“ã€ç¼“å†²åŒºéç©ºã€‘æ—¶ï¼Œä¸ä¼šéš[`Self::buffer_next`]çš„è°ƒç”¨è€Œæ”¹å˜
    /// * âš ï¸ä¸æ˜¯ã€Œç¼“å†²åŒºå¼€å¤´ã€æ‰€åœ¨çš„ç´¢å¼•
    ///   * åè€…ä¸ºã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€[`Self::buffer_head`]
    /// * âš ï¸å½“è‡ªèº«ã€æœªå¼€å§‹è¿­ä»£ã€‘æ—¶ï¼Œã€Œå¤´ç´¢å¼•ã€ä»ç„¶ä¸º`0`
    pub fn head(&self) -> usize {
        self.head
    }

    /// è·å–ã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€
    /// * ğŸš©æ˜¯ã€Œç¼“å†²åŒºå¼€å¤´ã€æ‰€åœ¨çš„ç´¢å¼•
    /// * ğŸ“Œä¸ä¼šéš[`Self::next`]çš„è°ƒç”¨è€Œæ”¹å˜
    /// * âš ï¸å½“è‡ªèº«ã€æœªå¼€å§‹è¿­ä»£ã€‘æ—¶ï¼Œã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€ä¸º`0`
    ///   * ğŸ“Œã€Œç¼“å†²åŒºé•¿åº¦ã€æ°¸è¿œä¸ä¼šå¤§äºã€Œå¤´ç´¢å¼•+1ã€
    ///   * ğŸ“Œè¿™ä¹Ÿè¯´æ˜ï¼š**å½“ã€Œç¼“å†²åŒºå¤´ç´¢å¼•>å¤´ç´¢å¼•ã€æ—¶ï¼Œç¼“å†²åŒºä¸ºç©º**
    pub fn buffer_head(&self) -> usize {
        (self.head + 1) - self.buffer.len()
    }

    /// è·å–ã€Œå¤´å…ƒç´ ã€ï¼ˆä¸å¯å˜å¼•ç”¨ï¼‰
    /// * ğŸ“Œå®é™…ä¸Šæ˜¯ã€Œç¼“å†²åŒºæœ«å°¾å…ƒç´ ã€
    /// * ğŸš©ç¼“å†²åŒºéç©ºâ‡’`Some(å¼•ç”¨)`ï¼Œç¼“å†²åŒºä¸ºç©ºâ‡’`None`
    pub fn head_item(&self) -> Option<&T> {
        self.buffer.back()
    }

    /// è·å–ã€Œç¼“å†²åŒºå¤´å…ƒç´ ã€ï¼ˆä¸å¯å˜å¼•ç”¨ï¼‰
    /// * ğŸ“Œå®é™…ä¸Šæ˜¯ã€Œç¼“å†²åŒºå¼€å¤´å…ƒç´ ã€
    /// * ğŸš©ç¼“å†²åŒºéç©ºâ‡’`Some(å¼•ç”¨)`ï¼Œç¼“å†²åŒºä¸ºç©ºâ‡’`None`
    pub fn buffer_head_item(&self) -> Option<&T> {
        self.buffer.front()
    }

    /// è·å–ã€Œå¤´å…ƒç´ ã€ï¼ˆå¯å˜å¼•ç”¨ï¼‰
    /// * ğŸ“Œå®é™…ä¸Šæ˜¯ã€Œç¼“å†²åŒºæœ«å°¾å…ƒç´ ã€
    /// * ğŸš©ç¼“å†²åŒºéç©ºâ‡’`Some(å¼•ç”¨)`ï¼Œç¼“å†²åŒºä¸ºç©ºâ‡’`None`
    pub fn head_item_mut(&mut self) -> Option<&mut T> {
        self.buffer.back_mut()
    }

    /// è·å–ã€Œç¼“å†²åŒºå¤´å…ƒç´ ã€ï¼ˆå¯å˜å¼•ç”¨ï¼‰
    pub fn buffer_head_item_mut(&mut self) -> Option<&mut T> {
        self.buffer.front_mut()
    }

    /// è·å–ã€Œæ˜¯å¦å·²å¼€å§‹ã€
    pub fn is_began(&self) -> bool {
        self.is_began
    }

    /// è·å–ã€Œæ˜¯å¦è¿­ä»£å®Œã€
    pub fn is_ended(&self) -> bool {
        self.is_ended
    }

    /// è·å–ã€Œç¼“å†²åŒºé•¿åº¦ã€
    pub fn len_buffer(&self) -> usize {
        self.buffer.len()
    }

    /// åˆ¤æ–­ã€Œç¼“å†²åŒºæ˜¯å¦ä¸ºç©ºã€
    pub fn is_buffer_empty(&self) -> bool {
        self.buffer.is_empty()
    }

    /// å¤´è¿­ä»£
    /// * ğŸš©å°è¯•ä»ã€Œå†…éƒ¨è¿­ä»£å™¨ã€ä¸­è¿­ä»£å‡ºä¸€ä¸ªå€¼ï¼Œç„¶åå°è¯•è¿”å›è¿™ä¸ªå€¼çš„**ä¸å¯å˜å¼•ç”¨**
    ///   * âš ï¸å¯èƒ½ä¼šè¿­ä»£ç»“æŸï¼Œæ­¤æ—¶è¿”å›[`None`]
    ///   * âŒæ— æ³•è¿”å›å¯å˜å¼•ç”¨ï¼š"cannot mutate immutable variable `item`"
    ///
    /// * â„¹ï¸è¦ä½¿ç”¨ã€Œå¤´è¿­ä»£å™¨ã€ï¼Œè¯·ä½¿ç”¨`while let Some(item) = iter.head_next()`
    pub fn head_next(&mut self) -> Option<&T> {
        // ä»å°è£…çš„è¿­ä»£å™¨ä¸­è¿­ä»£å‡ºä¸€ä¸ªå…ƒç´ 
        let item = self.iterator.next();
        // åˆ¤æ–­æ˜¯å¦ç»“æŸ
        match (self.is_began, item) {
            // æœªå¼€å§‹ï¼Œå°†è¦ç»§ç»­ | ç¬¬ä¸€ä¸ªå…ƒç´ 
            (false, Some(item)) => {
                // è®¾ç½®ã€Œå·²ç»å¼€å§‹ã€
                self.is_began = true;
                // å­˜å…¥ç¼“å†²åŒº
                self.buffer.push_back(item);
                // å¤´ç´¢å¼•ä¸å˜
                // å–å‡ºåˆšåˆšç½®å…¥å…ƒç´ çš„å¼•ç”¨
                Some(self.buffer.back().unwrap()) // * å­˜å…¥äº†å€¼
            }
            // å·²å¼€å§‹ï¼Œæ­£åœ¨ä¸­é€”
            (true, Some(item)) => {
                // å¤´ç´¢å¼•é€’å¢
                self.head += 1;
                // å­˜å…¥ç¼“å†²åŒº
                self.buffer.push_back(item);
                // å–å‡ºåˆšåˆšç½®å…¥å…ƒç´ çš„å¼•ç”¨
                Some(self.buffer.back().unwrap()) // * å­˜å…¥äº†å€¼
            }
            // å°†è¦ç»“æŸ
            (_, None) => {
                // è®¾ç½®ã€Œå·²ç»ç»“æŸã€
                self.is_ended = true;
                None // * æ²¡å­˜å…¥å€¼
            }
        }
        // ! ä½œä¸ºä¸€èˆ¬çš„ã€Œç¼“å­˜è¿­ä»£ã€ï¼Œä¸è¿”å›ã€Œå†…ç½®è¿­ä»£å™¨ã€è¿­ä»£å‡ºçš„å…ƒç´ 
    }

    /// ç¼“å†²åŒºè¿­ä»£ï¼šä»**ç¼“å†²åŒº**/**å†…ç½®è¿­ä»£å™¨**ä¸­æ‹¿å–å…ƒç´ 
    /// * âš ï¸æ€»æ˜¯ä¼šæ‹¿å‡ºå…ƒç´ ï¼ˆæ•…å¯èƒ½æ¶‰åŠç¼“å†²åŒºçš„ç´¢å¼•ï¼‰
    /// * ğŸš©åˆ†ã€Œç¼“å†²åŒºæ˜¯å¦ä¸ºç©ºã€æ‰§è¡Œ
    ///   * ç¼“å†²åŒºä¸ºç©ºâ‡’å°è¯•ä»ã€Œå†…éƒ¨è¿­ä»£å™¨ã€å–å‡ºå…ƒç´ ï¼ˆè°ƒç”¨[`Iterator::next`]ï¼‰
    ///   * ç¼“å†²åŒºéç©ºâ‡’ä»ç¼“å†²åŒºå¤´éƒ¨å–å‡ºä¸€ä¸ªå…ƒç´ ï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰ï¼Œå¹¶è¿”å›
    pub fn buffer_next(&mut self) -> Option<T> {
        // ç¼“å†²åŒºä¸ºç©ºâ‡’å¤´è¿­ä»£ï¼ˆå°è¯•å‘ã€Œå†…éƒ¨è¿­ä»£å™¨ã€ä¸­å–ï¼‰
        if self.is_buffer_empty() {
            // å¤´è¿­ä»£ï¼Œå°è¯•å‘ç¼“å†²åŒºå­˜å…¥å…ƒç´ 
            self.head_next();
        }
        // å°è¯•ä»ç¼“å†²åŒºå¤´éƒ¨å–å‡ºå…ƒç´ 
        self.buffer.pop_front()
        // ! æ­¤å¤„æ— éœ€å¤„ç†ã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€ï¼šä¼šè‡ªåŠ¨è®¡ç®—
    }

    /// å¤´è¿­ä»£ï¼ˆå¤šæ¬¡ï¼‰
    /// * ğŸš©æ‰§è¡Œå¤šæ¬¡å¤´è¿­ä»£ï¼ˆåç»­å¯ä¼˜åŒ–ï¼‰
    ///   * è¿”å›ã€Œæ˜¯å¦å®Œå…¨è¿­ä»£ã€ï¼Œå³æ˜¯å¦`n`æ¬¡éƒ½è¿­ä»£å‡ºäº†å…ƒç´ 
    pub fn head_next_n(&mut self, n: usize) -> bool {
        // é‡å¤næ¬¡ã€Œå¤´è¿­ä»£ã€
        (0..n)
            // åªæœ‰æ‰€æœ‰ã€Œå¤´ç´¢å¼•æ­¥è¿›ã€éƒ½æˆåŠŸæ—¶è¿”å›true
            .all(|_| self.head_next().is_some())
    }

    // ! âŒã€2024-03-04 20:58:35ã€‘å®è·µï¼šå› ä¸ºã€Œæ‰“åŒ…åéœ€è¦ä»ä¸­å€Ÿç”¨å€¼ã€çš„å€Ÿç”¨é—®é¢˜ï¼Œå†æ¬¡å¼ƒç”¨ã€Œç‹¬ç«‹ä½¿ç”¨ã€å¤´è¿­ä»£å™¨ã€ç®¡ç†è¿­ä»£è¿‡ç¨‹ã€çš„æƒ³æ³•
    // ! âŒã€2024-03-04 21:00:13ã€‘åŸºäºã€Œè¿­ä»£çŠ¶æ€ã€çš„ã€ŒçŠ¶æ€æœºæ¨¡å‹ã€ä¹Ÿä¸å¯ç”¨ï¼šã€Œå¤´è¿­ä»£ã€ã€Œç¼“å†²åŒºè¿­ä»£ã€è¿­ä»£å‡ºçš„æ˜¯ä¸¤ç§ä¸åŒçš„ç±»å‹`T`ä¸`&T`ï¼Œä¹Ÿæ²¡æ³•ç»Ÿä¸€
    // /// åŸºäºã€Œå¤´è¿­ä»£ã€ç”Ÿæˆã€Œå¤´è¿­ä»£å™¨ã€
    // /// * ğŸ¯ç”¨äºã€Œè¿­ä»£æ‰©å……è‡ªèº«ç¼“å†²åŒºï¼Œå¹¶è¿”å›ã€è¿­ä»£å‡ºçš„å…ƒç´ ã€çš„ä¸å¯å˜å¼•ç”¨ã€
    // /// * ğŸš©ç›®å‰å› ã€Œå¤´è¿­ä»£å™¨ç»“æ„çš„ç”Ÿå‘½å‘¨æœŸé—®é¢˜ã€**æ— æ³•ç›´æ¥è¿”å›ã€Œæ–°åŠ å…¥ç¼“å†²åŒºä¹‹å…ƒç´ çš„å¯å˜å¼•ç”¨ã€**
    // ///   * éœ€è¦ç»“åˆ[`Self::head_item`]æˆ–[`Self::head_item_mut`]ä½¿ç”¨
    // ///
    // /// ! âŒã€2024-03-04 20:29:30ã€‘åŸºäºç‰¹æ®Šã€Œå¤´è¿­ä»£å™¨ã€çš„ç»“æ„æ— æ•ˆï¼šæ— æ³•æœ‰æ•ˆå¤„ç†ç”Ÿå‘½å‘¨æœŸé—®é¢˜
    // /// * âŒã€Œä¼ å…¥è‡ªèº«ï¼Œç„¶åunwrapè§£åŒ…ã€çš„æ–¹æ³•ï¼šä¼šé‡åˆ°ã€Œè¿”å›å¼•ç”¨çš„æ–¹æ³•æ— æ•ˆã€çš„é—®é¢˜
    // pub fn into_head_iter(self) -> impl Iterator<Item = ()> {
    //     HeadIter::new(self)
    // }
    // ! å¼ƒç”¨ï¼šé—­åŒ…é—®é¢˜
    // pub fn head_iter(&mut self) -> impl Iterator<Item = &T> {
    //     FnIterator::new(|| match self.head_next() {
    //         true => Some(self.head_item().unwrap()),
    //         false => None,
    //     })
    // }

    /// ç¼“å†²åŒºè·å–
    /// * ğŸ“Œè‡ªç¼“å†²åŒºä»¥**ç›¸å¯¹ä½ç½®**ç´¢å¼•å…ƒç´ 
    ///   * ğŸ“Œä»¥ã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€ä¸ºèµ·ç‚¹ï¼ˆç¼“å†²åŒºå¤´ç´¢å¼•=>0ï¼‰
    /// * ğŸš©ç›´æ¥è·å–ç¼“å†²åŒºç›¸åº”ä½ç½®çš„å…ƒç´ 
    /// * âš ï¸è¶Šç•Œâ‡’å°è¯•ä»ã€Œå†…éƒ¨è¿­ä»£å™¨ã€ä¸­å–å‡ºå…ƒç´ 
    ///   * å®åœ¨å–ä¸åˆ°â‡’[`None`]
    pub fn buffer_get(&mut self, index: usize) -> Option<&T> {
        match index < self.len_buffer() {
            // * å·²ç»åˆ¤æ–­äº†ã€Œæ˜¯å¦è¶Šç•Œã€ï¼Œæ‰€ä»¥ç›´æ¥è¿›è¡Œæ•°ç»„ç´¢å¼•
            true => Some(&self.buffer[index]),
            // * è¶Šç•Œâ‡’å°è¯•æ‰©å±•ç¼“å†²åŒºï¼Œå¹¶è·å–å¤´éƒ¨ï¼ˆç¼“å†²åŒºæœ«å°¾ï¼‰å…ƒç´ 
            false => match self.head_next_n(index - self.len_buffer() + 1) {
                true => self.head_item(),
                false => None,
            },
        }
    }

    /// ç¼“å†²åŒºè¿­ä»£å™¨ï¼ˆä¸å¯å˜å¼•ç”¨ï¼‰
    pub fn buffer_iter(&self) -> impl Iterator<Item = &T> {
        self.buffer.iter()
    }

    /// ç¼“å†²åŒºè¿­ä»£å™¨ï¼ˆå¯å˜å¼•ç”¨ï¼‰
    pub fn buffer_iter_mut(&mut self) -> impl Iterator<Item = &mut T> {
        self.buffer.iter_mut()
    }

    /// ç¼“å†²åŒºæ¸…ç©º
    /// * ğŸ“Œã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€ä¼šè‡ªåŠ¨æ›´æ–°
    pub fn buffer_clear(&mut self) {
        self.buffer.clear();
    }

    /// ç¼“å†²åŒºè½¬ç§»ï¼ˆä»å‰å¾€åï¼‰
    /// * ğŸ¯åœ¨ã€Œæ¸…ç©ºç¼“å†²åŒºã€æ—¶ï¼Œéœ€è¦ä½¿ç”¨è¢«æ¸…ç©ºçš„å…ƒç´ 
    /// * ğŸ“Œå…¶å†…å…ƒç´ å‡è½¬ç§»ç»™å‚æ•°`f`
    /// * ğŸ“Œã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€ä¼šè‡ªåŠ¨æ›´æ–°
    pub fn buffer_transfer(&mut self, f: impl Fn(T)) {
        // æ¸…é™¤ã€Œç¼“å†²åŒºé•¿åº¦ã€ä¸ªå…ƒç´ ï¼Œå³æ¸…é™¤æ‰€æœ‰å…ƒç´ 
        for _ in 0..self.len_buffer() {
            f(self.buffer.pop_front().unwrap());
        }
    }

    /// ç¼“å†²åŒºè½¬ç§»ï¼ˆä»å‰å¾€åï¼Œå¯å˜ï¼‰
    /// * ğŸ¯åœ¨ã€Œæ¸…ç©ºç¼“å†²åŒºã€æ—¶ï¼Œéœ€è¦ä½¿ç”¨è¢«æ¸…ç©ºçš„å…ƒç´ ï¼Œå¹¶ä¸”è¿‡ç¨‹ä¸­ä¼šä¿®æ”¹å…¶å®ƒå¯¹è±¡ï¼ˆå¦‚ã€Œå°†å…ƒç´ åŠ å…¥æŸä¸ªæ•°ç»„ã€ï¼‰
    /// * ğŸ“Œå…¶å†…å…ƒç´ å‡è½¬ç§»ç»™å‚æ•°`f`
    pub fn buffer_transfer_mut(&mut self, mut f: impl FnMut(T)) {
        // æ¸…é™¤ã€Œç¼“å†²åŒºé•¿åº¦ã€ä¸ªå…ƒç´ ï¼Œå³æ¸…é™¤æ‰€æœ‰å…ƒç´ 
        for _ in 0..self.len_buffer() {
            f(self.buffer.pop_front().unwrap());
        }
    }
}

/// å®ç°è¿­ä»£å™¨æ¥å£ï¼Œå…¼å®¹[`Self::next`]æ–¹æ³•
impl<T, I> Iterator for BufferIterator<T, I>
where
    I: Iterator<Item = T>,
{
    type Item = T;

    /// ä½œä¸ºè¿­ä»£å™¨çš„è¿­ä»£ï¼šè‡ªåŠ¨é‡å®šå‘åˆ°ã€Œç¼“å†²åŒºè¿­ä»£ã€
    /// * ğŸ¯ç¡®ä¿ä¸€å®šä¼šè¿­ä»£å‡ºå…ƒç´ ï¼Œä¸”æ— éœ€[`Clone::clone`]å¤åˆ¶å…ƒç´ 
    /// * ğŸ¯ç¡®ä¿å…¶å°±åƒä¸€ä¸ªã€Œæ­£å¸¸è¿­ä»£å™¨ã€é‚£æ ·è¿­ä»£
    fn next(&mut self) -> Option<Self::Item> {
        // é‡å®šå‘åˆ°ã€Œç¼“å†²åŒºè¿­ä»£ã€
        self.buffer_next()
    }
}

/// å¯¹é¢å¤–å®ç°äº†[`PartialEq`]çš„å…ƒç´ å®ç°ã€Œä»¥æŒ‡å®šè¿­ä»£å…ƒç´ å¼€å¤´ã€ç­‰æ–¹æ³•
impl<T, I> BufferIterator<T, I>
where
    T: Clone + PartialEq,
    I: Iterator<Item = T>,
{
    /// åˆ¤æ–­æ˜¯å¦ä»¥`other_iter`çš„å…ƒç´ å¼€å¤´
    /// * ğŸš©ä»ã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€å¼€å§‹ï¼š**ä¼˜å…ˆä½¿ç”¨ç¼“å†²åŒºå†…å…ƒç´ **ï¼Œæ¯”å¯¹å®Œäº†å†ä»ã€Œå†…éƒ¨è¿­ä»£å™¨ã€ä¸­æ‹¿å–å…ƒç´ 
    ///   * æœ€å¤šå¯èƒ½æ–°æ‹¿å–`other_iter.count()`ä¸ªå…ƒç´ ï¼ˆ**æ¯”å¯¹è€…é•¿åº¦**ï¼‰
    /// * ğŸ¯ç”¨äºåœ¨è¯­æ³•è§£æä¸­å®ç°ã€Œå‰ç¼€åŒ¹é…ã€
    /// * âš ï¸ä¼šæ”¹å˜ç¼“å†²åŒºï¼Œä¸”ä¸åŒºåˆ†ã€Œå› ä¸åŒ¹é…è€Œã€éå‰ç¼€ã€ã€ä¸ã€Œå› è¿­ä»£å®Œè€Œã€éå‰ç¼€ã€ã€
    pub fn starts_with(&mut self, mut other_iter: impl Iterator<Item = T>) -> bool {
        // å…ˆæ¯”å¯¹ç¼“å†²åŒºä¸­çš„å…ƒç´ ï¼ˆä¸ä¼šæ”¹å˜è‡ªèº«ï¼‰ | æ­¤æ—¶ã€Œæ¯”å¯¹è€…ã€ç›¸å¯¹æœªçŸ¥
        for item_self in &self.buffer {
            // ! â†‘æ­¤å¤„`item_self`ä¸èƒ½åŠ `&`ï¼Œåªéœ€åœ¨éœ€è¦æ¯”å¯¹æ—¶è§£å¼•ç”¨
            // ä»ã€Œæ¯”å¯¹è€…ã€ä¸­å–å‡ºå…ƒç´ ä»¥å¯¹æ¯”
            match other_iter.next() {
                // åœ¨`false`ä¹‹å‰å°±æ²¡æœ‰â‡’è¿”å›`true`
                None => return true,
                // æ¯”å¯¹å¤±è´¥â‡’è¿”å›`false`
                Some(item_other) if *item_self != item_other => return false,
                // æ¯”å¯¹æˆåŠŸâ‡’ç»§ç»­
                _ => {}
            }
        }
        // å†ä»è‡ªèº«æ‹¿å‡ºæ¥æ¯”å¯¹ | æ­¤æ—¶ã€Œè‡ªèº«ã€ç›¸å¯¹æœªçŸ¥
        for item_other in other_iter {
            // ä»ã€Œå†…éƒ¨è¿­ä»£å™¨ã€ä¸­å–å‡ºå…ƒç´ ï¼Œç½®å…¥ç¼“å†²åŒº
            match self.head_next() {
                // ç„¶åå¯¹æ¯”
                // å†…éƒ¨è¿­ä»£å™¨ç”¨å°½â‡’è‡ªèº«é•¿åº¦ä¸å¤Ÿâ‡’è¿”å›`false`
                None => return false,
                // è¿­ä»£å‡ºå…ƒç´ â‡’ä»ç¼“å†²åŒºä¸­å–å‡ºå…ƒç´ ï¼Œå¯¹é½ï¼Œæ¯”å¯¹
                Some(item_self) => {
                    // æ¯”å¯¹å¤±è´¥â‡’è¿”å›`false`
                    if *item_self != item_other {
                        return false;
                    }
                }
            }
        }
        // æ¯”å¯¹éƒ½æ²¡å¤±è´¥â‡’æˆåŠŸâ‡’`true`
        true
    }

    /// è‹¥ä»¥`other_iter`çš„å…ƒç´ å¼€å¤´â‡’è·³è¿‡å…ƒç´ 
    /// * ğŸš©ä»ç„¶ä¼šè¿”å›ã€Œæ˜¯å¦ åŒ¹é…+è·³è¿‡ æˆåŠŸã€
    /// * ğŸ“Œè™½ç„¶è¦æ±‚ã€Œæ¯”å¯¹è€…é•¿åº¦ã€å·²çŸ¥ï¼Œä½†ã€Œæ¯”å¯¹è€…é•¿åº¦ã€åœ¨[`Self::starts_with`]è¿”å›`true`æ—¶å·²è•´å«ã€Œæ¯”å¯¹è€…é•¿åº¦å·²çŸ¥ã€
    ///   * ğŸš©å› æ­¤ä½¿ç”¨[`Iterator::map`]å°è£…è®¡æ•°é€»è¾‘ï¼Œå¹¶æ¶ˆè€—è¿­ä»£å™¨
    /// * ğŸš©æ¯”å¯¹æˆåŠŸåï¼Œä½¿ç”¨ã€Œç¼“å†²åŒºé€’è¿›ã€[`Self::buffer_next`]è·³è¿‡å…ƒç´ 
    ///   * ğŸ“Œå› ä¸ºæ˜¯ä»ç¼“å†²åŒºå¼€å§‹æ¯”å¯¹çš„
    pub fn skip_when_starts_with(&mut self, other_iter: impl Iterator<Item = T>) -> bool {
        let mut c: usize = 0;
        // ä½¿ç”¨é—­åŒ…è¾¹è¿­ä»£è¾¹è®¡æ•°ï¼ˆåç»­ç”¨äºè·³è¿‡æ¯”å¯¹è€…ï¼‰
        if self.starts_with(other_iter.map(|v| {
            // è¾¹è¿­ä»£è¾¹è®¡æ•°
            c += 1;
            v
        })) {
            // ä½¿ç”¨ã€Œç¼“å†²åŒºè¿­ä»£ã€è·³è¿‡æ¯”å¯¹è€…
            for _ in 0..c {
                self.next(); // ! ç›®çš„åœ¨æ¶ˆè€—ç¼“å†²åŒºå†…ã€åŒ¹é…äº†å‰ç¼€ã€‘çš„å…ƒç´ 
            }
            // è¿”å›ã€Œæ¯”å¯¹å¹¶è·³è¿‡æˆåŠŸã€
            return true;
        }
        // è¿”å›ã€Œæ¯”å¯¹å¤±è´¥ã€
        false
    }
}

/// ä¸ºå­—ç¬¦ä¸²å®ç°`into_chars`æ–¹æ³•
/// * ğŸ“„å‚è€ƒï¼šhttps://internals.rust-lang.org/t/is-there-a-good-reason-why-string-has-no-into-chars/19496/7
pub trait IntoChars {
    /// å°†è‡ªèº«è½¬æ¢ä¸ºå­—ç¬¦è¿­ä»£å™¨ï¼Œè·å–è‡ªèº«æ‰€æœ‰æƒ
    fn into_chars(self) -> impl Iterator<Item = char>;
}

/// å¯¹é™æ€å­—ä¸²å®ç°`into_chars`æ–¹æ³•
impl IntoChars for &str {
    fn into_chars(self) -> impl Iterator<Item = char> {
        self.to_owned().into_chars()
    }
}

/// å¯¹åŠ¨æ€å­—ä¸²å®ç°`into_chars`æ–¹æ³•
impl IntoChars for String {
    /// è¿ç§»è‡ª<https://github.com/rust-lang/libs-team/issues/268>
    /// * âš ï¸å°‘é‡ä¿®æ”¹
    ///   * ğŸš©ä½¿ç”¨è‡ªå·±çš„ã€Œå‡½æ•°å¼è¿­ä»£å™¨ã€
    ///   * ğŸ“Œä½¿ç”¨é—­åŒ…æ•è·è‡ªèº«ä½œä¸ºå˜é‡ï¼Œä»¥é¿å…ã€Œä¸´æ—¶å¼•ç”¨ã€é—®é¢˜
    fn into_chars(self) -> impl Iterator<Item = char> {
        let mut i = 0;
        // åˆ›å»ºå‡½æ•°å¼è¿­ä»£å™¨ï¼Œæ•è·å˜é‡`i`ä¸è‡ªèº«
        FnIterator::new(move || {
            if i < self.len() {
                let c = self[i..].chars().next().unwrap();
                i += c.len_utf8();
                Some(c)
            } else {
                None
            }
        })
    }
}

/// å•å…ƒæµ‹è¯•
#[cfg(test)]
mod tests {
    use crate::asserts;

    use super::*;

    /// å‡½æ•°å¼è¿­ä»£å™¨
    #[test]
    fn test_functional_iter() {
        // æ„é€ ä¸€ä¸ªã€Œä¸æ–­è¿­ä»£'a'ã€çš„è¿­ä»£å™¨
        let item = 'a';
        let mut iter = FnIterator::new(|| Some(item));
        const N: usize = 100000;
        for _ in 0..N {
            // è‚¯å®šè¿­ä»£å‡ºå…ƒç´ ï¼Œå¹¶ä¸”æ’ç­‰äº'a'
            assert_eq!(iter.next().unwrap(), item);
        }

        // æ„é€ ä¸€ä¸ª`i32`çš„ç©ºè¿­ä»£å™¨
        let iter = FnIterator::new(|| None::<i32>);
        assert_eq!(iter.count(), 0); // ä¸ä¼šæœ‰è®¡æ•°

        // æ„é€ ä¸€ä¸ªæ–æ³¢é‚£å¥‘è¿­ä»£å™¨
        let mut a_n1: usize = 0;
        let mut a_n2: usize = 0;
        let mut a_n3: usize = 1;
        let mut iter = FnIterator::new(|| {
            // è®¡ç®—æ–°æ•°æ®
            a_n1 = a_n2;
            a_n2 = a_n3;
            a_n3 = a_n1 + a_n2;
            // è¿”å›æ•°æ®
            Some(a_n2)
        });
        assert_eq!(iter.nth(10 - 1).unwrap(), 55); // `10-1`æ‰æ˜¯ã€Œç¬¬10ä¸ªã€
    }

    /// ä¸€æ¬¡æ€§æ¶ˆè€—æ‰è¿­ä»£å™¨
    #[test]
    fn iter_char_overview() {
        let test_set = [
            "abcd",
            "æˆ‘æ˜¯ä¸€ä¸ªè¿­ä»£å™¨",
            r"/rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library\std\src\panicking.rs:645",
            "âš ï¸æ³¨æ„ï¼šä¸èƒ½ä½¿ç”¨`collect`â—ï¼ŒğŸ¤”å…¶ä¼šè·å–è¿­ä»£å™¨çš„æ‰€æœ‰æƒï¼ˆå¯¼è‡´æ— æ³•çŸ¥æ™“ã€Œè¿­ä»£åçš„çŠ¶æ€ã€ï¼‰",
        ];
        for test_str in test_set {
            _iter_char_overview(test_str);
        }
    }

    fn _iter_char_overview(s: &str) {
        // âœ¨åˆ›å»ºè¿­ä»£å™¨
        let mut iter = BufferIterator::new(s.chars());

        // ! âš ï¸æ³¨æ„ï¼šä¸èƒ½ä½¿ç”¨`collect`ï¼Œå…¶ä¼šè·å–è¿­ä»£å™¨çš„æ‰€æœ‰æƒï¼ˆå¯¼è‡´æ— æ³•çŸ¥æ™“ã€Œè¿­ä»£åçš„çŠ¶æ€ã€ï¼‰
        asserts! {
            // è¿­ä»£ä¹‹å‰
            iter.head() => 0, // æ­¤æ—¶å¤´ç´¢å¼•ä¸º`0`ï¼ˆä½†å®é™…ä¸Šæ˜¯ã€Œæœªå¼€å§‹è¿­ä»£ã€çš„çŠ¶æ€ï¼‰
            iter.is_began() => false, // è¿˜æ²¡å¼€å§‹è¿­ä»£
            iter.is_ended() => false, // è¿˜æ²¡ç»ˆæ­¢è¿­ä»£
            iter.len_buffer() => 0, // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦ä¸º`0`
            iter.is_buffer_empty(), // æ­¤æ—¶ç¼“å†²åŒºä¸ºç©º
            iter.buffer_head() => 1, // æ­¤æ—¶ç¼“å†²åŒºå¤´ç´¢å¼•ä¸º`1`
        }

        // ä¸€æ¬¡æ€§è¿­ä»£å®Œå…ƒç´ 
        let mut to = String::new();
        // for _ in &mut head_iter { // ! å¼ƒç”¨ã€Œå¤´è¿­ä»£å™¨ã€çš„æ–¹å¼
        while let Some(c) = iter.head_next() {
            // é€šè¿‡ã€Œå¤´è¿­ä»£ã€åŠ ã€Œè·å–å¤´å…ƒç´ ã€å®ç°ã€Œä¸æ–­å¢æ‰©ç¼“å†²åŒºï¼Œå¹¶è¿”å›æ–°å¢æ‰©çš„å…ƒç´ çš„å¼•ç”¨ã€çš„æ•ˆæœ
            to.push(*c); // ! è‡ªåŠ¨copyäº†
        }

        // ! ğŸ“å­—ç¬¦ä¸²é•¿åº¦ â‰  å­—ç¬¦é•¿åº¦ï¼ˆå­—ç¬¦ä¸ªæ•°ï¼‰
        let len_chars_to = to.chars().count();

        // è¿­ä»£ä¹‹å
        asserts! {
            to => s, // è¿­ä»£åˆ°å­—ç¬¦ä¸²ä¸­ï¼Œä»ç„¶ä¿æŒåŸæ ·
            iter.head() => len_chars_to - 1, // æ­¤æ—¶å¤´ç´¢å¼•ä¸ºã€Œå­—ç¬¦é•¿åº¦-1ã€ï¼ˆç»ˆæ€ï¼‰
            iter.is_began(), // å·²ç»å¼€å§‹è¿­ä»£
            iter.is_ended(), // å·²ç»ç»ˆæ­¢è¿­ä»£
            iter.len_buffer() => len_chars_to, // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦ä¸ºã€Œå­—ç¬¦é•¿åº¦ã€
            iter.is_buffer_empty() => false, // æ­¤æ—¶ç¼“å†²åŒºéç©º
            iter.buffer_head() => 0, // æ­¤æ—¶ç¼“å†²åŒºå¤´ç´¢å¼•ä¸º`0`ï¼ˆå› ä¸ºæ²¡æ¶ˆè€—ç¼“å†²åŒºï¼‰
        }

        // å†æ¸…ç©ºç¼“å†²åŒº
        iter.buffer_clear();

        asserts! {
            iter.head() => len_chars_to - 1, // æ­¤æ—¶å¤´ç´¢å¼•ä¸å˜ï¼ˆç»ˆæ€ï¼‰
            iter.is_began(), // å·²ç»å¼€å§‹è¿­ä»£
            iter.is_ended(), // å·²ç»ç»ˆæ­¢è¿­ä»£
            iter.len_buffer() => 0, // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦æ¸…é›¶
            iter.is_buffer_empty(), // æ­¤æ—¶ç¼“å†²åŒºä¸ºç©º
            iter.buffer_head() => len_chars_to, // æ­¤æ—¶ç¼“å†²åŒºå¤´ç´¢å¼•ä¸ºã€Œå­—ç¬¦é•¿åº¦ã€ï¼Œä¸ºç©ºâ‡”æ¯”ã€Œå¤´ç´¢å¼•ã€å¤§`1`
        }
    }

    /// ä¸€æ­¥æ­¥æµ‹è¯•è¿­ä»£å™¨
    #[test]
    fn iter_char_per_step() {
        // âœ¨åˆ›å»ºè¿­ä»£å™¨
        let mut iter = BufferIterator::new("abcd".chars());

        // ! å°½å¯èƒ½ä¸è¦å°è¯•åœ¨ã€Œå¼€å§‹è¿­ä»£å‰ã€è·å–ã€Œå¤´ç´¢å¼•ã€
        asserts! {
            iter.head() => 0 // æ­¤æ—¶å¤´ç´¢å¼•ä¸º`0`ï¼ˆä½†å®é™…ä¸Šæ˜¯ã€Œæœªå¼€å§‹è¿­ä»£ã€çš„çŠ¶æ€ï¼‰
            iter.is_began() => false // è¿˜æ²¡å¼€å§‹è¿­ä»£
            iter.is_ended() => false // è¿˜æ²¡ç»ˆæ­¢è¿­ä»£
            iter.len_buffer() => 0, // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦ä¸º`0`
            iter.is_buffer_empty(), // æ­¤æ—¶ç¼“å†²åŒºä¸ºç©º
            iter.buffer_head() => 1 // æ­¤æ—¶ç¼“å†²åŒºå¤´ç´¢å¼•ä¸º`1`
        }

        // è¿­ä»£å™¨ã€å¤´è¿­ä»£ã€‘ä¸€æ¬¡ // ! è¿­ä»£å‡ºçš„å­—ç¬¦ã€å­˜è¿›ç¼“å†²åŒºã€‘ï¼Œå¤´ä¹Ÿã€ä¸ç§»åŠ¨ã€‘
        let cached_a = iter.head_next();

        asserts! {
            cached_a => Some(&'a') // è¿­ä»£å‡ºçš„å­—ç¬¦æ˜¯'a'
            iter.buffer_get(0) => Some(&'a') // ç¼“å†²åŒºç¬¬ä¸€ä¸ªå…ƒç´ ä¸º
            iter.head() => 0 // æ­¤æ—¶å¤´ç´¢å¼•åœ¨`0`
            iter.is_began() => true // æ­¤æ—¶å·²å¼€å§‹è¿­ä»£
            iter.is_ended() => false // æ­¤æ—¶æœªè¿­ä»£ç»ˆæ­¢
            iter.is_buffer_empty() => false // æ­¤æ—¶ç¼“å†²åŒºéç©º
            iter.len_buffer() => 1 // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦ä¸º`1`
            iter.buffer_head() => 0 // æ­¤æ—¶ç¼“å†²åŒºå¤´ç´¢å¼•åœ¨`0`ï¼ˆç¼“å†²åŒºåªæœ‰ç¬¬ä¸€ä¸ªï¼‰
        }

        // è¿­ä»£å™¨ã€ç¼“å†²åŒºè¿­ä»£ã€‘ä¸€æ¬¡ // ! æ­¤æ—¶å› ä¸ºç¼“å†²åŒºå·²ç¼“å­˜ï¼Œæ‰€ä»¥ç¼“å†²åŒºæ¶ˆè€—å¹¶è¿”å›æœ€å‰ä¸€ä¸ªå­—ç¬¦`'a'`
        let a2 = iter.buffer_next();

        asserts! {
            a2 => Some('a'), // åº”è¯¥æŠŠç¼“å­˜çš„ç¬¬ä¸€ä¸ªå­—ç¬¦å¼¹å‡º
            iter.head() => 0, // æ­¤æ—¶å¤´ç´¢å¼•ä¸å˜
            iter.is_began() => true, // æ­¤æ—¶å·²å¼€å§‹è¿­ä»£
            iter.is_ended() => false, // æ­¤æ—¶ä»æœªç»“æŸ
            iter.is_buffer_empty(), // æ­¤æ—¶ç¼“å†²åŒºä¸ºç©º
            iter.len_buffer() => 0, // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦ä¸º`0`
            iter.buffer_head() => 1, // æ­¤æ—¶ã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€å˜ä¸º`1`
        }

        // è¿­ä»£å™¨å†æ¬¡ã€ç¼“å†²åŒºè¿­ä»£ã€‘ // ! æ­¤æ—¶å› ä¸ºç¼“å†²åŒºã€ä¸ºç©ºã€‘ï¼Œæ‰€ä»¥ã€Œå†…éƒ¨è¿­ä»£å™¨ã€è¿­ä»£å‡ºå…ƒç´ ï¼Œå¤´ç´¢å¼•å’Œç¼“å†²åŒºç´¢å¼•åŒæ—¶ç§»åŠ¨
        let b = iter.buffer_next();

        asserts! {
            b => Some('b') // æ­¤æ—¶æ²¡æœ‰ç¼“å­˜äº†ï¼Œæ‰€ä»¥è¿­ä»£å‡ºäº†æ–°å­—ç¬¦
            iter.head() => 1 // æ­¤æ—¶å¤´ç´¢å¼•æ­¥è¿›åˆ°`1`
            iter.is_began() => true // æ­¤æ—¶å·²å¼€å§‹è¿­ä»£
            iter.is_ended() => false, // æ­¤æ—¶ä»æœªç»“æŸ
            iter.is_buffer_empty(), // æ­¤æ—¶ç¼“å†²åŒºä¸ºç©ºï¼ˆæœ¬æ¥ä¸ºç©ºï¼Œæ­¤æ—¶è¿˜æ˜¯ç©ºï¼‰
            iter.len_buffer() => 0 // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦ä¸º`0`
            iter.buffer_head() => 2 // æ­¤æ—¶ã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€æ­¥è¿›åˆ°`2`
        }

        // è¿­ä»£å™¨é€šè¿‡ã€Œç¼“å†²åŒºè·å–ã€æ‰©å±•å…ƒç´  // ! æ­¤æ—¶å› ä¸ºç¼“å†²åŒºã€ä¸ºç©ºã€‘ï¼Œæ‰€ä»¥ã€Œå†…éƒ¨è¿­ä»£å™¨ã€è¿­ä»£å‡ºå…ƒç´ ï¼Œå¤´ç´¢å¼•å’Œç¼“å†²åŒºç´¢å¼•åŒæ—¶ç§»åŠ¨
        let c = iter.buffer_get(0);

        asserts! {
            c => Some(&'c') // æ­¤æ—¶æ²¡æœ‰ç¼“å­˜äº†ï¼Œæ‰€ä»¥è¿­ä»£å‡ºäº†æ–°å­—ç¬¦
            iter.head() => 2 // æ­¤æ—¶å¤´ç´¢å¼•æ­¥è¿›åˆ°`1`
            iter.is_began() => true // æ­¤æ—¶å·²å¼€å§‹è¿­ä»£
            iter.is_ended() => false // æ­¤æ—¶ä»æœªç»“æŸ
            iter.is_buffer_empty() => false // æ­¤æ—¶ç¼“å†²åŒºéç©ºï¼ˆå› ä¸ºå¤´ç´¢å¼•æ­¥è¿›ï¼Œç¼“å†²åŒºæ”¶åˆ°äº†æ–°å­—ç¬¦ï¼‰
            iter.len_buffer() => 1 // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦ä¸º`1`
            iter.buffer_head() => 2 // æ­¤æ—¶ã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€ä¸å˜
        }

        // è¿­ä»£å™¨æµ‹è¯•åç»­æ˜¯å¦ä»¥"c" "cd" "ä¸ä¼šæ¯”å¯¹æˆåŠŸ"å¼€å¤´ï¼Œåœ¨æ­¤ä¸­å°†'c'ã€'d'åŠ å…¥ç¼“å†²åŒº
        let starts_with_cd = iter.starts_with("cd".chars());
        let starts_with_c = iter.starts_with("c".chars());
        let starts_with_ä¸ä¼šæ¯”å¯¹æˆåŠŸ = iter.starts_with("ä¸ä¼šæ¯”å¯¹æˆåŠŸ".chars());

        asserts! {
            starts_with_cd // çš„ç¡®æ˜¯ä»¥"cd"å¼€å¤´ | æ¯”å¯¹è€…æ¯”ç¼“å†²åŒºé•¿
            starts_with_c, // çš„ç¡®æ˜¯ä»¥"c"å¼€å¤´ | æ¯”å¯¹è€…åœ¨ç¼“å†²åŒºå†…
            starts_with_ä¸ä¼šæ¯”å¯¹æˆåŠŸ => false // çš„ç¡®ä¸ä»¥"ä¸ä¼šæ¯”å¯¹æˆåŠŸ"å¼€å¤´ | æ¯”å¯¹è€…è¶…å‡ºè‡ªèº«ç•Œé™
            iter.head() => 3 // æ­¤æ—¶å¤´ç´¢å¼•æ›´æ–°åˆ°äº†`3`â€”â€”ä¸ºäº†ã€Œå‰ç¼€åŒ¹é…ã€ä¸€ç›´åœ¨å¢åŠ ç´¢å¼•
            iter.is_began() => true // æ­¤æ—¶å·²å¼€å§‹è¿­ä»£
            iter.is_ended() => false // æ­¤æ—¶ä»æœªç»“æŸ | ä¸´ç•ŒçŠ¶æ€ï¼šè¿˜æœªç»§ç»­è°ƒç”¨`next`æ–¹æ³•
            iter.is_buffer_empty() => false // æ­¤æ—¶ç¼“å†²åŒºéç©º
            iter.len_buffer() => 2 // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦ä¸º`2`
            iter.buffer_head() => 2 // æ­¤æ—¶ã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€ä¸å˜
        }

        // æµ‹è¯•"c"å¼€å¤´ï¼Œå¹¶ï¼ˆåœ¨ç¼“å†²åŒºé‡Œï¼‰è·³è¿‡å®ƒ
        let skipped = iter.skip_when_starts_with("c".chars());

        asserts! {
            skipped => true // çš„ç¡®æ˜¯ä»¥"c"å¼€å¤´å¹¶è·³è¿‡äº†
            iter.head() => 3 // æ­¤æ—¶å¤´ç´¢å¼•ä¸å˜â€”â€”æ¯”å¯¹æ²¡æœ‰è¶…å‡ºç¼“å†²åŒº
            iter.is_began() => true // æ­¤æ—¶å·²å¼€å§‹è¿­ä»£
            iter.is_ended() => false // æ­¤æ—¶ä»æœªç»“æŸ | ä¸´ç•ŒçŠ¶æ€ï¼šè¿˜æœªç»§ç»­è°ƒç”¨`next`æ–¹æ³•
            iter.is_buffer_empty() => false // æ­¤æ—¶ç¼“å†²åŒºéç©º
            iter.len_buffer() => 1 // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦å‡å°‘åˆ°`1`ï¼ˆè·³è¿‡äº†"c"ï¼‰
            iter.buffer_head() => 3 // æ­¤æ—¶ã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€å¢åŠ åˆ°`3`ï¼ˆè·³è¿‡äº†"c"ï¼‰
        }

        // è¿­ä»£å™¨èµ°åˆ°å°½å¤´
        let none = iter.head_next();

        asserts! {
            none => None // å·²ç»æ²¡æœ‰å¯è¿­ä»£çš„äº†
            iter.head() => 3, // æ­¤æ—¶å¤´ç´¢å¼•ä¸å˜
            iter.is_began() // æ­¤æ—¶å·²å¼€å§‹è¿­ä»£
            iter.is_ended(), // æ­¤æ—¶å·²ç»ç»“æŸ | åˆšå¥½è¶…è¿‡
            iter.is_buffer_empty() => false // æ­¤æ—¶ç¼“å†²åŒºéç©º
            iter.len_buffer() => 1 // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦ä¸å˜
            iter.buffer_head() => 3 // æ­¤æ—¶ã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€ä¸å˜
        }

        // æœ€åçš„ç¼“å†²åŒºè½¬äº¤
        let mut d = String::new();
        iter.buffer_transfer_mut(|c| d.push(c));

        asserts! {
            d => "d" // è½¬äº¤å‡ºæ¥çš„å­—ç¬¦ä¸²æ˜¯"d"
            iter.head() => 3, // æ­¤æ—¶å¤´ç´¢å¼•ä¸å˜
            iter.is_began() // æ­¤æ—¶å·²å¼€å§‹è¿­ä»£
            iter.is_ended() // æ­¤æ—¶å·²ç»ç»“æŸ
            iter.is_buffer_empty(), // æ­¤æ—¶ç¼“å†²åŒºä¸ºç©º
            iter.len_buffer() => 0 // æ­¤æ—¶ç¼“å†²åŒºé•¿åº¦æ¸…é›¶
            iter.buffer_head() => 4 // æ­¤æ—¶ã€Œç¼“å†²åŒºå¤´ç´¢å¼•ã€å¢åŠ åˆ°`4`ï¼ˆä¸ºç©ºä¹‹åæ¯”ã€Œå¤´ç´¢å¼•ã€å¤§ï¼‰
        }
    }
}
