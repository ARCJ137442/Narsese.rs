//! ä¸€äº›å®ç”¨å·¥å…·ã€å®šä¹‰ã€å‡½æ•°
//! * ğŸ“Œå®å®šä¹‰ä¸“é—¨æ”¾åœ¨[`macros.rs`]ä¸­
//!   * ğŸ“„å‚è€ƒæ ‡å‡†åº“ä¸å…¶å®ƒåŒ…ï¼ˆå¦‚`winnow`ï¼‰

use crate::push_str;

/// ç»Ÿä¸€æŒ‡å®šã€Œç²¾åº¦ã€ç±»å‹
/// * ğŸ¯çœŸå€¼
/// * ğŸ¯é¢„ç®—å€¼
/// * ğŸ’«éš¾ç‚¹ï¼šæ— æ³•é€šè¿‡æ³›å‹å¤„ç†å½¢å¦‚ `f32 | f64` çš„ç±»å‹æ ‡æ³¨
///   * ğŸ•šæ—¶é—´ï¼šã€2024-02-19 22:42:18ã€‘
///   * âŒæ— æ³•å¤„ç†ã€Œç±»å‹æ¯”å¯¹ã€çš„æ“ä½œï¼ˆf32æ— æ³•å’Œf64æ¯”å¯¹ï¼Œåä¹‹äº¦ç„¶ï¼Œä¸å…¼å®¹ï¼‰
///   * âŒæ— æ³•ä½¿ç”¨ã€Œç»Ÿä¸€ç‰¹å¾ã€çš„æ–¹å¼
///     * ğŸš©æ–¹æ³•ä»£ç ï¼š`trait Float{}; impl Float for f32 {}; impl Float for f64 {};`
///   * âŒæ— æ³•å¤„ç†ã€Œæ„é€ ä¼ å‚ã€ä¸­æœ‰å…³çš„ã€Œå¸¸é‡è½¬æ¢æ“ä½œã€
///     * â—ç±»ä¼¼`new_single(1.0)`ï¼Œæ­¤ä¸­ä¹‹å¸¸é‡æ— æ³•è½¬æ¢ä¸ºã€Œç²¾åº¦ã€å¯¹è±¡
///     * âŒæ— æ³•ä½¿ç”¨`as`ï¼šæ— æ³•é™åˆ¶`Precision`ä¸ºåŸºç¡€ç±»å‹
///     * âŒæ— æ³•ä½¿ç”¨`From<f64>`çš„æ–¹æ³•ï¼š[`f32`]æœªå®ç°[`From<f64>`]ç‰¹å¾ï¼Œåä¹‹äº¦ç„¶
pub type FloatPrecision = f64;
/// é»˜è®¤çš„æ•´æ•°ç²¾åº¦
/// * ğŸ¯æ—¶é—´æˆ³/å›ºå®šæ—¶é—´ | OpenNARS/PyNARSå‡æ”¯æŒã€Œè´Ÿæ•´æ•°æ—¶é—´ã€
pub type IntPrecision = isize;

/// ã€Œ0-1ã€å®æ•°
/// ğŸ“Œé€šè¿‡ç‰¹å¾ä¸ºæµ®ç‚¹æ•°æ·»åŠ ã€Œ0-1 é™åˆ¶ã€æ–¹æ³•
///   * ğŸ“è€Œéç›´æ¥`impl FloatPrecision`ï¼šå­¤å„¿è§„åˆ™
pub trait ZeroOneFloat {
    /// åˆ¤æ–­æ˜¯å¦åœ¨èŒƒå›´å†…
    fn is_in_01(&self) -> bool;
    /// éªŒè¯ã€Œ0-1ã€åˆæ³•æ€§
    /// * ğŸ“ŒçŸ­æš‚å€Ÿèµ°æ‰€æœ‰æƒï¼Œæ¯”å¯¹åå½’è¿˜
    /// * âš ï¸è‹¥ä¸åœ¨èŒƒå›´å†…ï¼Œåˆ™äº§ç”Ÿpanic
    fn validate_01(self) -> Self;
}

/// å®ç°
impl ZeroOneFloat for FloatPrecision {
    fn is_in_01(&self) -> bool {
        *self >= 0.0 && *self <= 1.0
    }
    fn validate_01(self) -> Self {
        if self < 0.0 || self > 1.0 {
            panic!("ã€Œ0-1ã€åŒºé—´å¤–çš„å€¼ï¼ˆå»ºè®®ï¼š`0<x<1`ï¼‰");
        }
        self
    }
}

/// å•å…ƒæµ‹è¯•/ã€Œ0-1ã€å®æ•°
#[cfg(test)]
mod tests_01_float {
    use crate::{fail_tests, show};

    use super::*;
    /// è¾…åŠ©ç”¨æµ‹è¯•å®/æˆåŠŸæµ‹è¯•
    /// ! ğŸ“`, $(,)?`è¿™é‡Œçš„ã€Œ,ã€ä»£è¡¨çš„ä¸æ˜¯ã€Œåˆ†éš”è¡¨è¾¾å¼ã€ï¼Œè€Œæ˜¯ã€Œæ¨¡å¼ä¸­çš„`,`ã€
    /// * æ•…åº”å»é™¤è¿™å‰è¾¹çš„ã€Œ,ã€
    macro_rules! test_valid {
        // ğŸ“å®é™…ä¸Šè¿™é‡Œè¾¹å•¥æ‹¬å·éƒ½å¯ä»¥
        [$($num:expr),* $(,)?] => {
            $(
                let v = $num.validate_01();
                assert_eq!(v, $num);
                show!($num.validate_01());
            )*
        };
    }

    #[test]
    fn test_01_float_valid() {
        test_valid![0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];
    }

    /// è¾…åŠ©ç”¨æµ‹è¯•å®/å¤±è´¥æµ‹è¯•
    /// ! ğŸ“`, $(,)?`è¿™é‡Œçš„ã€Œ,ã€ä»£è¡¨çš„ä¸æ˜¯ã€Œåˆ†éš”è¡¨è¾¾å¼ã€ï¼Œè€Œæ˜¯ã€Œæ¨¡å¼ä¸­çš„`,`ã€
    /// * æ•…åº”å»é™¤è¿™å‰è¾¹çš„ã€Œ,ã€
    macro_rules! test_all_invalid {
        ($($name:ident => $num:expr),* $(,)?) => {
            // ç›´æ¥ç”¨`fail_tests!`ç”Ÿæˆå¤±è´¥æµ‹è¯•
            fail_tests!{
                $(
                    $name {
                        $num.validate_01();
                    }
                )*
            }
        };
    }

    test_all_invalid! {
        // å¤§æ•°
        fail_1_1 => 2.0,
        fail_3_0 => 3.0,
        fail_10_0 => 10.0,
        // è´Ÿæ•°
        fail_n_0_1 => -0.1,
        fail_n_0_2 => -0.2,
        fail_n_2_0 => -2.0,
    }
}

/// å·¥å…·å‡½æ•°/æœ‰å†…å®¹æ—¶å‰ç¼€åˆ†éš”ç¬¦
/// * ğŸ¯æœ€åˆç”¨äºã€Œå¤šä¸ªç”¨ç©ºæ ¼åˆ†éš”çš„æ¡ç›®ã€ä¸­ã€Œè‹¥å…¶ä¸­æœ‰ç©ºå­—ä¸²ï¼Œå°±æ— éœ€è¿ç»­ç©ºæ ¼ã€çš„æƒ…å†µ
/// * å…³é”®åœ¨ã€Œé¿å…æ— ç”¨åˆ†éš”ç¬¦ã€
pub fn add_space_if_necessary_and_flush_buffer(
    out: &mut String,
    buffer: &mut String,
    separator: &str,
) {
    match buffer.is_empty() {
        // ç©ºâ‡’ä¸åšåŠ¨ä½œ
        true => {}
        // éç©ºâ‡’é¢„ç½®åˆ†éš”ç¬¦ï¼Œæ¨é€å¹¶æ¸…ç©º
        false => {
            push_str!(out; separator, buffer);
            buffer.clear();
        }
    }
}

/// å·¥å…·å‡½æ•°/ç”¨åˆ†éš”ç¬¦æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œä¸”å½“å…ƒç´ ä¸ºç©ºæ—¶é¿å…è¿ç»­åˆ†éš”ç¬¦
/// * ğŸ¯æœ€åˆç”¨äºã€Œå¤šä¸ªç”¨ç©ºæ ¼åˆ†éš”çš„æ¡ç›®ã€ä¸­ã€Œè‹¥å…¶ä¸­æœ‰ç©ºå­—ä¸²ï¼Œå°±æ— éœ€è¿ç»­ç©ºæ ¼ã€çš„æƒ…å†µ
/// * ğŸ“Œå®é™…ä¸Šæ˜¯[`add_space_if_necessary_and_flush_buffer`]çš„å¦ä¸€ç§å½¢å¼
///
/// # Example
/// ```rust
/// use enum_narsese::util::join_lest_multiple_separators;
/// let mut s = String::new();
/// join_lest_multiple_separators(&mut s, vec!["a", "", "b", "c", "", "d"].into_iter(), ",");
/// assert_eq!(s, "a,b,c,d");
/// ```
pub fn join_lest_multiple_separators<'a, I>(out: &mut String, mut elements: I, separator: &str)
where
    I: Iterator<Item = &'a str>,
{
    // å…ˆåŠ å…¥ç¬¬ä¸€ä¸ªå…ƒç´ 
    match elements.next() {
        // æœ‰å…ƒç´ â‡’ç›´æ¥åŠ å…¥
        Some(s) => out.push_str(s),
        // æ— å…ƒç´ â‡’ç›´æ¥è¿”å›
        None => return,
    };
    // å…¶åã€Œå…ˆè€ƒè™‘åˆ†éš”ï¼Œå†æ·»åŠ å…ƒç´ ã€
    for element in elements {
        match element.is_empty() {
            // ç©ºå­—ä¸²â‡’æ²¡å¿…è¦æ·»åŠ 
            true => continue,
            // éç©ºå­—ä¸²â‡’è¿åŒåˆ†éš”ç¬¦ä¸€å¹¶æ·»åŠ 
            false => push_str!(out; separator, element),
        }
    }
}
